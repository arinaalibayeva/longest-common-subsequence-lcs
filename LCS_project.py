# -*- coding: utf-8 -*-
"""LCS_CS110.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YBxaHiK2VLcOmY1Fzu9gBotaOo08yn__

## Longest Common Subsequence
I compute the LCSs for any two arbitrary strings and their corresponding lengths. I included 4 given test cases and changed the order accordingly.
"""

def longest_common_subsequences(x, y):
    """
    Gives the length of the longest common substring between strings x and y

    Inputs
    ---------
    x, y: strings
        Strings to compute the LCS
    Returns
    ---------
    all_lcs: tuple ([LCS1, LCS2, ...], len(LCS1))
        Tuple of a list of all the possible LCS and the corresponding length (size)
    """
    if not x or not y:
        return (None, 0)   # If the string is empty, no LCS exists

    # Build the DP table
    m, n = len(x), len(y)
    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]

    # Fill out the table using bottom-up DP
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if x[i - 1] == y[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    # Backtrack the table to find all the LCS
    st = set()  # To store LCS
    visited = set()

    def backtrack(i, j, current_lcs):
        """"
        Recursive function to backtrack the DP table and cimpute all the possible LCS.

        Parameters
        ----------
        i : int
            Current row index
        j : int
            Current column index
        current_lcs : str
            The LCS in the reverse order

        Returns
        ----------
        None
        """

        if i == 0 or j == 0:  # Base case
            st.add(current_lcs[::-1])
            return
        if (i, j, current_lcs) in visited:  # Avoid redundant processing
            return
        visited.add((i, j, current_lcs))

        if x[i - 1] == y[j - 1]:
            backtrack(i - 1, j - 1, current_lcs + x[i - 1])
        else:
            if dp[i - 1][j] == dp[i][j]:  # From top
                backtrack(i - 1, j, current_lcs)
            if dp[i][j - 1] == dp[i][j]:  # From left
                backtrack(i, j - 1, current_lcs)

    backtrack(m, n, "") # Backtracking starts from the bottom-right corner of the DP table

    # Return sorted LCSs and their length
    all_lcs = sorted(st)
    return (all_lcs, dp[m][n])


# Test cases
x1, y1 = 'ABCBDAB', 'BDCABA'
x2, y2 = 'abc', ''
x3, y3 = 'abc', 'a'
x4, y4 = 'abc', 'ac'

assert longest_common_subsequences(x1, y1) == (['BCAB', 'BCBA', 'BDAB'], 4), f"Test Case 1 failed: {longest_common_subsequences(x1, y1)}"
assert longest_common_subsequences(x2, y2) == (None, 0), f"Test Case 2 failed: {longest_common_subsequences(x2, y2)}"
assert longest_common_subsequences(x3, y3) == (['a'], 1), f"Test Case 3 failed: {longest_common_subsequences(x3, y3)}"
assert longest_common_subsequences(x4, y4) == (['ac'], 2), f"Test Case 4 failed: {longest_common_subsequences(x4, y4)}"

print("All test cases passed!")

"""### The matrix of the lengths of the LCS for every pair of strings in set_strings
The matrix has dimenstion(7,7) and gives the length of the LCS for the ith and jth strings.
"""

import numpy as np

def lcs_tables(x, y):
    """
    Builds the DP table for computing the Longest Common Subsequence (LCS) between two strings.

    Parameters
    -----------

    x, y: strings
        Strings to compute the LCS

    Returns
    --------
    dp : list of lists
        2D DP table where dp[i][j] represents the LCS length between x[:i] and y[:j].
    """
    m, n = len(x), len(y)
    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]

    # Fill the table one row at a time
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if x[i - 1] == y[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp

def lcs_length(x, y):
    """
    Computes the length of the Longest Common Subsequence (LCS) between two strings.

    Parameters
    -----------

    x, y: strings
        Strings to compute the LCS

    Returns
    --------
    int
        Length of the LCS between x and y.
    """
    dp = lcs_tables(x, y)
    return dp[len(x)][len(y)]  # The value in the bottom-right cell of the table

def print_lcs_matrix_with_grid(matrix, labels):
    """
    Outputs an LCS matrix with a grid and row/column labels.

    Parameters:
    -----------
    matrix : np.array
        The matrix containing LCS lengths between strings.
    labels : list
        List of labels for strings corresponding to rows and columns.

    Returns:
    --------
    None
    """
    # Calculate the width of each cell
    cell_width = max(len(str(val)) for row in matrix for val in row) + 2

    # Print the header row with centered labels
    header = " " * (cell_width + 1)
    header += " ".join([f"{label:^{cell_width}}" for label in labels])
    print(header)
    print("-" * len(header))

    # Print each row with labels
    for i, row in enumerate(matrix):
        row_label = f"{labels[i]:^{cell_width}}"
        row_values = []
        for j, val in enumerate(row):
            if i == j:
                bold_val = f"\033[1m{val:^{cell_width}}\033[0m"  # Bold text using ANSI escape codes
                row_values.append(bold_val)
            else:
                row_values.append(f"{val:^{cell_width}}")
        print(row_label + " ".join(row_values))
        print("-" * len(header))


# Given input strings
set_strings = [
    ('a', 'ATGGTGCGAAAGCATCTCTTTTCGTGGCGTGATAAGTTTTATGGTATCCCCGGACGTTGGCTACTACAATTCTCCGAAGTATAAGTGAGTAGGATATGTCAATAACAAGA'
          'GGGGATGCGTGACGCATTAGCACCAACTGAATCAAACGATAACTAACGTGGTTTCAGTGAGCGTATGTGGCAAAGGATTGGATACATTTTTCGAGCACGTCTACATAATGA'
          'CCGTGACAATACTGGAGACTCCGTACCGTCATCTTGACACTCCT'),
    ('b', 'TGGTGCGAAAGCATCTCTTTTCCGTGGCGTATAGTTTTATGGTATCCCCGGAACGCTGGCTACTACAATCTCCGAAGTATAGAGTGAGTAGATTTAATTAACAGAGGGCG'
          'TCGTTGACGCATTAGCACCAACTGAATCAACCGATAACTTAACGTGGGTTTCAGTGACTATAGGGCAAAGGATGAACATTTTCGAGCAGCTCTAATAATGAGCGTGACAAT'
          'ATGAATCCACACCGTCATCTTGAACTCCT'),
    ('c', 'TCTGTGCGATATACATCTCTATCGTTGCGGTATGTTTTATGTGCATCACCCCACGCGCTGGCTACAGTACAATCTGCTGGAAGTACTAGGTGGTAGTTAATAACTAGGGT'
          'GCGTCGTTGCGCATTACACAACTGGACAACCACTTAACTGGGGTAATCAGTGTTTAGGGCAGACAAGATGAAAACAAGTTTTCGAGCAGGCTCCTATAATGAGGACGGAAC'
          'GTTAATAAATCCAACACCGCACTGCTTCGTAACCCT'),
    ('d', 'ATGAGGCGCAAAATTCTCTTTCTCGTGGCGCTGATTAAGTTTTATGTATCCCCGGACGTTGGCTACTGACAATTGCTCCGAAGTATAAAGTAGTAGGATATGTCAATAAC'
          'AAAGACGGGGATAGCGTGACAGCATTAGAACGCAACTGGAATCAAACGTAACCTAAAGGGTTGTCAGGAGCGTATGTGGTCAAAAAGGATTGGATGACATTTTTCGACACG'
          'TCTACATAATGACCTGTGACAAACTAGGAGACCTCCTACTCGGTCAATCTTGACGACTCCT'),
    ('e', 'TGGTGCGATATACATCTCTTTTCGTGCGTATGTTTTATGGTGATCACCCGGAACCGCTGGCTACATACAATCTCTGGAAGTACTAGGTGGTAGTTTAATAACTAGAGGTG'
          'CGTCGTTGACGCATTACACAACTGGATCAACCGAACTTAACTGGGTATCAGTGATATAGGGCGACAAGATGAACAATTTTCGAGCAGCTCCTGAATAATGAGACGGAACGT'
          'ATAATCCAACACCGTCACTGCTTCGAACCCT'),
    ('f', 'GGGGGAAAGCGATCCCTTATCGTGGCTGTGATAAGTTTTTATCGGGTATCCGCCGGACGTTGGCGTACTACAATTCTCCGAAGTTAAGTGAGTTAGGGATATAGTCAATA'
          'ACAAGAGGGGATTGTCGTGACGCATAGCACACAACTGAATCAAATCGATAACTAAACGGGTTTCAGTAGAGCGTTGTGGCAAAGATTGGATACATTTTTCGCAGGACGTCT'
          'TACCTAATGACGTGGACAATAACTGGCAGACGTCCGTACCGTCATCTTGACCACTCCCT'),
    ('g', 'TGGTGCGATATACATCCTCTTTTCGTGCGTATGTTTTAGGTACACCGGATACGCCTGGCTTACAAGTACCAATCTCTGAGAAGTCACTGAGGTGGTAGTTTAATAACTAG'
          'AAGGGTGCGTCGGACGCATTCACACATACTGGATCAACCGAGACTTAACTGGGGTATCAGTGATTGATAGGGCGACAAGATATACAATTTTCGAGCAGCTCCCTGAATAAG'
          'TGAAGAACGGAGACGTATAATCCAACACGATTCACTGCTTCGAACCCT')
]

n = len(set_strings)
labels = [item[0] for item in set_strings]
len_lcs_matrix = np.zeros((n, n), dtype=int)

# Fill the LCS matrix
for i in range(n):
    for j in range(i, n):
        if i == j:
            len_lcs_matrix[i][j] = len(set_strings[i][1])
        else:
            len_lcs_matrix[i][j] = len_lcs_matrix[j][i] = lcs_length(set_strings[i][1], set_strings[j][1])

print_lcs_matrix_with_grid(len_lcs_matrix, labels)

"""## How many LCSs lengths are there in set_strings?
The code below calculate the total number of LCS lengths and the number of unique LCS lengths. The second code focuses on the same thing but it excludes the diagonal values.
"""

# Create a single list with all the LCS lengths
all_lcs_lengths = [len_lcs_matrix[i][j] for i in range(n) for j in range(n)]

# Calculate total and unique lengths
total_lengths = len(all_lcs_lengths)
unique_lcs_lengths = set(all_lcs_lengths)
unique_lengths = len(unique_lcs_lengths)

print(f"Total LCS lengths: {total_lengths}")
print(f"Unique LCS lengths: {unique_lengths}")
print("Unique LCS lengths:", sorted(unique_lcs_lengths))

# Create a single list of all LCS lengths excluding the diagonal values
all_lcs_lengths = [
    len_lcs_matrix[i][j] for i in range(n) for j in range(n) if i != j
]

# Calculate total and unique lengths excluding the diagonal
total_lengths = len(all_lcs_lengths)
unique_lengths = len(set(all_lcs_lengths))

print(f"Total LCS lengths (excluding diagonal): {total_lengths}")
print(f"Unique LCS lengths (excluding diagonal): {unique_lengths}")
print("Unique LCS lengths:", sorted(set(all_lcs_lengths)))

"""## Genealogy Binary Tree LOCAL Strategy
I used greedy approach to build a genealogy binary tree by comparing each node with its immediate neighbors.
"""

import numpy as np

def build_tree_greedy(len_lcs_matrix, strings):
    """
    Constructs a binary tree using a local strategy to identify grandparent, parent, and child relationships.

    Parameters:
    -----------
    len_lcs_matrix: np.array
        2D numpy array with LCS lengths between strings.
    strings: list of str
        List of strings in the dataset.

    Returns:
    --------
    tree: list of tuples
        List of relationships in the form (Parent, Child1, Child2).
    """
    n = len(strings)
    visited = set()  # Visited nodes
    tree = []

    # Find the root with the highest pairwise LCS value
    max_lcs = -1
    root = -1
    for i in range(n):
        for j in range(i + 1, n):
            if len_lcs_matrix[i][j] > max_lcs:
                max_lcs = len_lcs_matrix[i][j]
                root = i
    visited.add(root)


    # Assign children to each parent iteratively
    queue = [root]
    while queue:
        parent = queue.pop(0)

        # Find two closest unvisited neighbors
        max1, max2 = -1, -1
        child1, child2 = -1, -1
        for i in range(n):
            if i not in visited and len_lcs_matrix[parent][i] > max1:
                max2, child2 = max1, child1
                max1, child1 = len_lcs_matrix[parent][i], i
            elif i not in visited and len_lcs_matrix[parent][i] > max2:
                max2, child2 = len_lcs_matrix[parent][i], i

        if child1 != -1 and child2 != -1:
            tree.append((strings[parent][0], strings[child1][0], strings[child2][0]))
            queue.extend([child1, child2])  # Add children to the queue to process
            visited.update([child1, child2])

    return tree

len_lcs_matrix = compute_lcs_matrix(set_strings)
tree = build_tree_greedy(len_lcs_matrix, set_strings)

print("\nGenealogy Tree (Local Strategy):")
for parent, child1, child2 in tree:
    print(f"Parent: {parent}, Child1: {child1}, Child2: {child2}")

"""## Genealogy Binary Tree GLOBAL Strategy
I used dynamic programming using a "Similarity Ratio Score" metric.
"""

import numpy as np

def similarity_ratio(x, y):
    """
    Calculates the similarity ratio between x and y strings.
    The similarity ratio is calculated as the length of LCS divided by the average length of the two strings.

    Parameters
    ----------
    x, y : str
        The two strings to compare.

    Returns
    -------
    float
        The similarity ratio between the two strings.
    """
    if not x or not y:
        return 0.0

    m, n = len(x), len(y)
    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]

    # Build the DP table
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if x[i - 1] == y[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    # Normalize by the average length of the two strings
    lcs_length = dp[m][n]
    avg_length = (m + n) / 2
    return round(lcs_length / avg_length, 3)

def similarity_ratio_matrix(set_strings):
    """
    Constructs a symmetric matrix with the similarity ratio values.

    Parameters
    ----------
    set_strings : list of tuples
        Each tuple contains a label and a sequence.

    Returns
    -------
    tuple : (numpy.ndarray, list)
        - matrix : 2D symmetric numpy array
        - labels : List of string labels corresponding to the sequences.
    """
    n = len(set_strings)
    labels = [item[0] for item in set_strings]
    matrix = np.zeros((n, n))

    for i in range(n):
        for j in range(i, n):
            if i == j:
                matrix[i][j] = 1.0  # Similarity with itself is always 1
            else:
                sim_ratio = similarity_ratio(set_strings[i][1], set_strings[j][1])
                matrix[i][j] = matrix[j][i] = sim_ratio

    return matrix, labels

def build_tree_similarity_ratio(set_strings, len_lcs_matrix):
    """
    Builds a genealogy tree using the Similarity Ratio metric.
    The root is the string with the highest total similarity ratio.

    Parameters
    ----------
    set_strings : list of tuples
        Each tuple contains a label and a sequence.
    len_lcs_matrix : numpy.ndarray
        A symmetric matrix with similarity ratio values between all strings.

    Returns
    -------
    tuple : (dict, dict, float)
        - tree_structure : The genealogy tree structure.
        - similarity_scores : Similarity ratio values between connected nodes.
        - total_similarity : Total sum of all similarity ratio values.
    """
    labels = [item[0] for item in set_strings]
    n = len(labels)
    used = set()

    # Find the grandparent (highest total similarity ratio)
    total_lcs = np.sum(len_lcs_matrix, axis=1)
    grandparent_idx = np.argmax(total_lcs)
    grandparent = labels[grandparent_idx]
    used.add(grandparent)

    # Find the two parents
    remaining = [label for label in labels if label not in used]
    max1, max2 = -1, -1
    parent1, parent2 = None, None
    for candidate in remaining:
        score = len_lcs_matrix[grandparent_idx][labels.index(candidate)]
        if score > max1:
            max2, parent2 = max1, parent1
            max1, parent1 = score, candidate
        elif score > max2:
            max2, parent2 = score, candidate
    parents = [parent1, parent2]
    used.update(parents)

    # Assign children to each parent
    def assign_children(parent, remaining):
        parent_idx = labels.index(parent)
        max1, max2 = -1, -1
        child1, child2 = None, None
        for candidate in remaining:
            score = len_lcs_matrix[parent_idx][labels.index(candidate)]
            if score > max1:
                max2, child2 = max1, child1
                max1, child1 = score, candidate
            elif score > max2:
                max2, child2 = score, candidate
        return [child1, child2]

    tree_structure = {'Grandparent': grandparent, 'Parents': [], 'Children': []}
    similarity_scores = {}
    total_similarity = 0

    # Assign parents
    tree_structure['Parents'] = parents
    for parent in parents:
        similarity_scores[(grandparent, parent)] = len_lcs_matrix[grandparent_idx][labels.index(parent)]
        total_similarity += similarity_scores[(grandparent, parent)]

    # Assign children
    for parent in parents:
        remaining = [label for label in labels if label not in used]
        children = assign_children(parent, remaining)
        for child in children:
            if child is not None:
                child_idx = labels.index(child)
                parent_idx = labels.index(parent)
                similarity_score = len_lcs_matrix[parent_idx][child_idx]
                similarity_scores[(parent, child)] = similarity_score
                total_similarity += similarity_score
                used.add(child)
                tree_structure['Children'].append((parent, child))

    return tree_structure, similarity_scores, total_similarity

def print_similarity_tree(tree_structure, similarity_scores, total_similarity):
    """
    Outputs the genealogy tree using the Similarity Ratio Metric.

    Parameters
    ----------
    tree_structure : dict
        The genealogy tree structure.
    similarity_scores : dict
        Similarity ratio values between nodes.
    total_similarity : float
        Score used to construct the tree.
    """
    print("Genealogy Tree (DP Approach with Similarity Ratio):")
    print(f"Grandparent: {tree_structure['Grandparent']}")

    print("\nParents:")
    for parent in tree_structure['Parents']:
        print(f"  {parent}")
        print(f"    Similarity Ratio with grandparent: {similarity_scores[(tree_structure['Grandparent'], parent)]}")

    print("\nChildren:")
    for parent, child in tree_structure['Children']:
        print(f"  {child} (Child of {parent})")
        print(f"    Similarity Ratio with parent {parent}: {similarity_scores[(parent, child)]}")

    print(f"\nTotal Similarity Ratio Metric: {total_similarity}")

len_lcs_matrix, labels = similarity_ratio_matrix(set_strings)
tree, similarity_scores, total_similarity = build_tree_similarity_ratio(set_strings, len_lcs_matrix)
print_similarity_tree(tree, similarity_scores, total_similarity)

"""## Comparison of the Execution Time: fixed length of genes, increasing number of genes.
I compared the runtime of both approaches, focusing on increasing the number of genes n, when the length of genes M is fixed.
"""

import numpy as np
import matplotlib.pyplot as plt
import time

# Local algorithm
def build_tree_greedy(len_lcs_matrix, strings):
    """
    Constructs a binary tree using a local strategy to identify grandparent, parent, and child relationships.

    Parameters:
    -----------
    len_lcs_matrix: np.array
        2D numpy array with LCS lengths between strings.
    strings: list of str
        List of strings in the dataset.

    Returns:
    --------
    tree: list of tuples
        List of relationships in the form (Parent, Child1, Child2).
    """
    n = len(strings)
    visited = set()
    tree = []

    max_lcs = -1
    root = -1
    for i in range(n):
        for j in range(i + 1, n):
            if len_lcs_matrix[i][j] > max_lcs:
                max_lcs = len_lcs_matrix[i][j]
                root = i
    visited.add(root)

    queue = [root]
    while queue:
        parent = queue.pop(0)
        max1, max2 = -1, -1
        child1, child2 = -1, -1
        for i in range(n):
            if i not in visited and len_lcs_matrix[parent][i] > max1:
                max2, child2 = max1, child1
                max1, child1 = len_lcs_matrix[parent][i], i
            elif i not in visited and len_lcs_matrix[parent][i] > max2:
                max2, child2 = len_lcs_matrix[parent][i], i

        if child1 != -1 and child2 != -1:
            tree.append((strings[parent], strings[child1], strings[child2]))
            queue.extend([child1, child2])
            visited.update([child1, child2])

    return tree

# Global algorithm
def build_tree_similarity_ratio(len_lcs_matrix, labels):
    """
    Builds a genealogy tree using the Similarity Ratio metric.
    The root is the string with the highest total similarity ratio.

    Parameters
    ----------
    set_strings : list of tuples
        Each tuple contains a label and a sequence.
    len_lcs_matrix : numpy.ndarray
        A symmetric matrix with similarity ratio values between all strings.

    Returns
    -------
    tuple : (dict, dict, float)
        - tree_structure : The genealogy tree structure.
        - similarity_scores : Similarity ratio values between connected nodes.
        - total_similarity : Total sum of all similarity ratio values.
    """
    n = len(labels)
    used = set()

    total_lcs = np.sum(len_lcs_matrix, axis=1)
    grandparent_idx = np.argmax(total_lcs)
    used.add(grandparent_idx)

    def assign_children(parent_idx):
        """
    Identifies the most similar unvisited children for a parent.

    Parameters
    ----------
    parent_idx : int
        The index of the parent node.

    Returns
    -------
    tuple
        The indices of the two most similar children (child1, child2).
        """
        max1, max2 = -1, -1
        child1, child2 = -1, -1
        for i in range(n):
            if i not in used and len_lcs_matrix[parent_idx][i] > max1:
                max2, child2 = max1, child1
                max1, child1 = len_lcs_matrix[parent_idx][i], i
            elif i not in used and len_lcs_matrix[parent_idx][i] > max2:
                max2, child2 = len_lcs_matrix[parent_idx][i], i
        return child1, child2

    total_time = 0
    for _ in range(n):
        parent_idx = grandparent_idx
        total_time += sum(assign_children(parent_idx))

    return total_time

# Time complexity experiments
n_values = np.arange(10, 110, 10)  # Number of genes
m_fixed = 100  # Fixed length of genes

local_times = []
global_times = []

for n in n_values:

    len_lcs_matrix = np.random.rand(n, n)
    len_lcs_matrix = (len_lcs_matrix + len_lcs_matrix.T) / 2
    np.fill_diagonal(len_lcs_matrix, 1)

    strings = [f"String_{i}" for i in range(n)]

    # Measure local algorithm time
    start_time = time.time()
    build_tree_greedy(len_lcs_matrix, strings)
    local_times.append(time.time() - start_time)

    # Measure global algorithm time
    start_time = time.time()
    build_tree_similarity_ratio(len_lcs_matrix, strings)
    global_times.append(time.time() - start_time)

plt.figure(figsize=(10, 6))
plt.plot(n_values, local_times, label="Local Algorithm", marker="o")
plt.plot(n_values, global_times, label="Global Algorithm", marker="s")
plt.title("Time Complexity: Local vs Global Algorithm")
plt.xlabel("Number of Genes (n)")
plt.ylabel("Execution Time (seconds)")
plt.legend()
plt.grid(True)
plt.show()

"""## Probability Estimation"""

def lcs_length(x, y):
    """
    Calculate the length of the Longest Common Subsequence (LCS) between two strings.

    Parameters
    ----------
    x : str
        The first string to compare.
    y : str
        The second string to compare.

    Returns
    -------
    int
        The length of the Longest Common Subsequence (LCS) between the two strings.
    """
    m, n = len(x), len(y)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if x[i - 1] == y[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    return dp[m][n]

def estimate_probabilities(set_strings):
    """
    Estimate probabilities of insertions, deletions, and mutations using pairwise LCS.

    Parameters
    ----------
    set_strings : list of tuples
        A list of tuples with a label and a corresponding string.

    Returns
    -------
    dict
        A dictionary containing the estimated probabilities:
    """
    insertions, deletions, mutations = 0, 0, 0
    n = len(set_strings)

    for i in range(n):
        for j in range(i + 1, n):  # Compare each pair of strings once
            x, y = set_strings[i][1], set_strings[j][1]
            lcs_len = lcs_length(x, y)

            # Compute changes
            ins = len(y) - lcs_len
            del_ = len(x) - lcs_len
            mut = min(ins, del_)  # Assume minimum mismatches as mutations

            # Accumulate changes
            insertions += ins
            deletions += del_
            mutations += mut

    # Total changes (insertions + deletions + mutations)
    total_changes = insertions + deletions + mutations

    # Normalize to get probabilities
    prob_insert = insertions / total_changes if total_changes > 0 else 0
    prob_delete = deletions / total_changes if total_changes > 0 else 0
    prob_mutate = mutations / total_changes if total_changes > 0 else 0

    return {
        "Insertion Probability": prob_insert,
        "Deletion Probability": prob_delete,
        "Mutation Probability": prob_mutate
    }

# Estimate probabilities
probabilities = estimate_probabilities(set_strings)
print("Estimated Probabilities:", probabilities)

"""## Scaling Growth"""

# Extract the data points for Local and Global Algorithm runtimes
for n, local_time, global_time in zip(n_values, local_times, global_times):
    print(f"n = {n}, Local Algorithm Time = {local_time:.6e}, Global Algorithm Time = {global_time:.6e}")

# Convert times to microseconds (1 second = 1,000,000 microseconds)
print("Runtime Values (in microseconds):")
for n, local_time, global_time in zip(n_values, local_times, global_times):
    local_time_us = local_time * 1e6
    global_time_us = global_time * 1e6
    print(f"n = {n}, Local Algorithm Time = {local_time_us:.2f} µs, Global Algorithm Time = {global_time_us:.2f} µs")

import numpy as np
import matplotlib.pyplot as plt

# Values of n and corresponding times
n_values = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90, 100])
local_times_us = np.array([98.94, 317.10, 454.90, 2088.79, 861.88, 1504.89, 1985.07, 2451.90, 3102.78, 3824.95])
global_times_us = np.array([272.04, 494.72, 1931.19, 1147.03, 2235.89, 2675.06, 3567.93, 4791.98, 5737.78, 6802.08])

# Calculate scaling ratios
n1, n2 = 40, 80
idx1, idx2 = np.where(n_values == n1)[0][0], np.where(n_values == n2)[0][0]

# Ratios
local_ratio = local_times_us[idx2] / local_times_us[idx1]
global_ratio = global_times_us[idx2] / global_times_us[idx1]
expected_ratio = (n2 / n1) ** 2  # Quadratic scaling for O(n^2)

print(f"Local Algorithm Ratio: {local_ratio:.2f}, Expected: {expected_ratio:.2f}")
print(f"Global Algorithm Ratio: {global_ratio:.2f}, Expected: {expected_ratio:.2f}")

# Log-log plot
plt.figure(figsize=(10, 6))
plt.loglog(n_values, local_times_us, label="Local Algorithm", marker="o")
plt.loglog(n_values, global_times_us, label="Global Algorithm", marker="s")
plt.title("Log-Log Plot: Local vs Global Algorithm")
plt.xlabel("Number of Genes (n)")
plt.ylabel("Execution Time (μs)")
plt.legend()
plt.grid(True, which="both", linestyle="--", linewidth=0.5)
plt.show()
